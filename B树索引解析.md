# 1 B树索引

在讲B树索引之前，先讨论什么是平衡二叉树(AVL Trees)，`B-`树,`B+`树，[文章参考](https://www.cnblogs.com/xiaohouye/p/11169098.html "参考")。

## 1.1 AVL Tree
AVL Tree满足以下特征：
1. 平衡二叉树的左右两个子树的高度差的绝对值不超过1，
2. 每个结点的左右两个子树都是一棵平衡二叉树。

![平衡二叉树](https://imgkr.cn-bj.ufileos.com/00b0a3c6-b3f0-4238-9300-f76d7fa0122f.jpg)

## 1.2 B- Tree

B-Tree 满足以下特性：
1. 每个结点最多有m个子节点；
2. 除了根结点和叶子结点外，每个结点最少有m/2(向上取整)个子结点；
3. 如果根结点不是叶子结点，那根结点至少包含两个子结点；
4. 所有的叶子结点都位于同一层；
5. 每个结点都包含k个元素（关键字），这里 $ m/2\leq k<m $,$ m/2 $ 向下取整；
6. 每个结点中元素(关键字)从小到大排列；
7. 每个元素（关键字）左结点的值都小于或等于该元素（关键字），右结点的值都大于或等于该元素(关键字)

## 1.3 B+ Tree

B+ Tree 满足以下特性：
1. 所有的非叶子结点只存储关键字信息。
2. 所有数据都存在叶子结点中。
3. 所有的叶子结点中包含了全部元素的信息。
4. 所有叶子结点之间都有一个链指针。

## 1.4 B- vs B+
1. `B- Tree`因为非叶子结点也保存具体数据，所以在查找某个关键字的时候找到即可返回。而`B+ Tree`所有的数据都在叶子结点，每次查找都得到叶子结点。所以在同样高度的`B- Tree`和`B+ Tree`中，`B- Tree`查找某个关键字的效率更高。

2. 由于`B+ Tree`所有的数据都在叶子结点，并且结点之间有指针连接，在找大于某个关键字或者小于某个关键字的数据的时候，`B+ Tree`只需要找到该关键字然后沿着链表遍历就可以了，而`B- Tree`还需要遍历该结点的关键字去搜索。

3. 由于`B-Tree`的每个结点（这里的结点可以理解为一个数据页）都存储主键+实际数据，而`B+Tree`非叶子结点只存储关键字信息，而每个页的大小有限是有限的，所以同一页能存储的`B-Tree`的数据会比`B+Tree`存储的更少。这样同样总量的数据，`B-Tree`的深度会更大，增大查询时的磁盘`I/O`次数，进而影响查询效率。

鉴于以上的比较，所以在常用的关系型数据库中，都是选择`B+Tree`的数据结构来存储数据！

# 2 操作系统文件管理

操作系统从磁盘读取数据到内存是以磁盘块（`block`）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理： 当一个数据被用到时，其附近的数据也通常会马上被使用。预读的长度一般为页（`page`）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页的大小通常为`4k`）。

# 3 InnoDB引擎数据存储

在InnoDB存储引擎中，也有页的概念，默认每个页的大小为16K，也就是每次读取数据时都是读取 $ 4\times4k $ 的大小！在某个页内插入新行时，为了不减少数据的移动，通常是插入到当前行的后面或者是已删除行留下来的空间，所以在某一个页内的数据并不是完全有序的（后面页结构部分有细讲），但为了数据访问顺序性，在每个记录中都有一个指向下一条记录的指针，以此构成了一条单向有序链表.


## 3.1 Insert数据

新增一条数据，但是Page1已经放不下数据了，这时候就需要进行页分裂，产生一个新的`Page`。在`InnoDB`中的流程是怎么样的呢？

1. 产生新的Page2，然后将Page1的内容复制到Page2。
2. 产生新的Page3，“秦寿生”的数据放入Page3。
3. 原来的Page1依然作为根结点，但是变成了一个不存放数据只存放索引的页，并且有两个子结点Page2、Page3。

>注意：如果是重新创建根结点，那根结点存储的物理地址可能经常会变，不利于查找。并且在`InnoDB`中根结点是会预读到内存中的，所以结点的物理地址固定会比较好！

每次新增数据，都是将一个页写满，然后新创建一个页继续写，这里其实是有个隐含条件的，那就是主键自增！主键自增写入时新插入的数据不会影响到原有页，插入效率高！且页的利用率高！但是如果主键是无序的或者随机的，那每次的插入可能会导致原有页频繁的分裂，影响插入效率！降低页的利用率！这也是为什么在`InnoDB`中建议设置主键自增的原因！

## 3.2 Select 数据

查找一条数据，过程如下：
1. 找到数据所在的页。这个查找过程就跟前面说到的B+Tree的搜索过程是一样的，从根结点开始查找一直到叶子结点。
2. 在页内找具体的数据。读取第1步找到的叶子结点数据到内存中，然后通过分块查找的方法找到具体的数据。

# 4 MyISAM引擎数据存储
1. 主键索引树的叶子结点的数据区域没有存放实际的数据，存放的是数据记录的地址。
2. 数据的存储不是按主键顺序存放的，按写入的顺序存放。

也就是说`InnoDB`引擎数据在物理上是按主键顺序存放，而`MyISAM`引擎数据在物理上按插入的顺序存放。并且`MyISAM`的叶子结点不存放数据，所以非聚集索引的存储结构与聚集索引类似，在使用非聚集索引查找数据的时候通过非聚集索引树就能直接找到数据的地址了，不需要回表，这比`InnoDB`的搜索效率会更高呢！