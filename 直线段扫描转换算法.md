# 1直线段扫描转换算法
数学上，直线上的点有无穷多个，但计算机光栅显示器屏幕上无法使用无限点来满足直线的表示，这时显示直线需要做一些处理。用有限的点来逼近无限的点形成直线。

为了在光栅显示器上用这些离散的像素点逼近这条直线需要知道这些像素的坐标。对直线上点坐标进行分段取整获得光栅坐标。
$$ y=kx+b \tag{1}$$
$$k=(y_1-y_0)/(x_1-x_0)\tag{2}$$
对于直线上的每一个点坐标，通过(2)式计算斜率$k$，使用横坐标$x_i$带入(1)式得到对应$y$的坐标，由于对应坐标值必须为整数，所以使用四舍五入方式对$y$取整得到坐标。

>为了提高效率把计算量减下来，关键问题是把**乘法**取消？直线段扫描算法便随之产生。

绘制直线算法主要分为以下三种：

1. 数值微分法(DDA算法)
2. 中点画线法
3. Bresenham算法

# 2数值微分法
`DDA`(Digital Differential Analyzer)算法，提出一种增量思想，使用直线斜截式方程
$$y_i=kx_i+b\tag{3}$$
$$y_{i+1}=kx_{i+1}+b$$
$$y_{i+1}=kx_{i}+k+b$$
$$y_{i+1}=y_{i}+k\tag{4}$$

通过公式（4）可以知道，当通过$x_i,y_i$获得下一个直线段坐标时，只需要通过$y_i$增加一个$k$.

改进效率：一般情况下$k$是小数，而且每一步运算都要对$y$进行四舍五入后取整。
1. 将浮点运算变成整数加法，能有效降低计算复杂度；
2. 直线方程有很多类型，如两点式、斜截式、一般式等。

# 3中点画线法
中点画线法采用直线一般式方程。

点在直线，则有:
$$f(x,y)=0$$
点在直线**上方**，则有：
$$f(x,y)>0$$
点在直线**下方**，则有：
$$f(x,y)<0$$
每次在最大位移方向上走一步，而另一个方向是走步还是不走步取决于中点误差项的判断。

![中点画线模型](https://imgkr.cn-bj.ufileos.com/9aaa9e13-68c5-4957-9cf2-5ed78bcc865b.png)

将M带入理想方程$$f(x_m,y_m)=Ax_m+By_m+C$$
$$d=f(x_m,y_m)$$
当$d<0$,M在Q的下方选$p_u$
当$d>0$,M在Q的上方选$p_d$
当$d=0$,M在直线上，选$p_d$或$p_u$都可以。
$$
y=
\begin{cases}
y+1,& \text{if $d$ < 0}\\
y,& \text{if $d \ge$ 0}
\end{cases}
$$

$$d=A(x+1)+B(y+0.5)+C$$

此时求$d$有两个**乘法**和一个**加法**运算。通过增量思想减少乘法运算。

$$d_1=f(x_m,y_m)$$
$$d_1=A(x+2)+B(y+1.5)+C$$
$$d_1=A(x+1)+B(y+0.5)+A+B+C$$
$$d_1=d_0+A+B\tag{5}$$

---
$$d_1=f(x_m,y_m)$$
$$d_1=A(x+2)+B(y+0.5)+C$$
$$d_1=A(x+1)+B(y+0.5)+A+C$$
$$d_1=d_0+A\tag{6}$$

---
$$d_1=f(x_m,y_m)$$
$$d_1=A(x+1)+B(y+0.5)+C$$
$$d_1=A(x+1)+By+0.5B+C$$
$$d_1=d_0+A+B\tag{7}$$

通过增量思想求的
$$
d_{new}=
\begin{cases}
d_{old}+A+B,& \text{if $d$ < 0}\\
d_{old}+A,& \text{if $d \ge$ 0}
\end{cases}
$$

$$d_0=A+0.5B+C$$

# 4Bresenham算法
该算法思想是通过各行、各列像素中心构造一组虚拟网格线，按照直线起点到终点的顺序，计算直线与各垂直网格线的交点，然后根据误差项的符号确定该列像素点中与此交点最近的元素。
![](https://imgkr.cn-bj.ufileos.com/eba0b502-d7cf-4873-875b-5f4f4266d299.png)

初始误差$d_0=0$
$$d=d+k$$
当$d>1$时，$d-1$保证$d$的相对性。
$$y_{i+1}=x_i+1$$
$$y_{i+1}=
\begin{cases}
y_i+1,& \text{if $d$ > 0.5}\\
y_i,& \text{if $d \le$ 0.5}
\end{cases}
$$

